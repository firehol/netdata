# Ensure that Riak is running.
template: riak_last_collected_secs
      on: riak.kv.throughput.gets
    calc: $now - $last_collected_t
   units: seconds ago
   every: 10s
    warn: $this > (($status >= $WARNING)  ? ($update_every) : ( 5 * $update_every))
    crit: $this > (($status == $CRITICAL) ? ($update_every) : (60 * $update_every))
   delay: down 5m multiplier 1.5 max 1h
    info: number of seconds since the last successful data collection
      to: dba

# Warn if a list keys operation is running.
template: riak_list_keys_active
      on: riak.core.fsm_active.list_keys
   units: running list keys finite state machines
   every: 10s
    warn: $this > 0
    info: number of currently running list keys finite state machines
      to: dba


## Timing healthchecks
template: 1h_kv_get_mean_latency
      on: riak.kv.latency.get.mean
  lookup: average -1h unaligned of time
   every: 30s
   units: ms
    info: mean average kv get latency over the last hour

template: riak_kv_get_slow
      on: riak.kv.latency.get.mean
  lookup: average -3m unaligned of time
   units: ms
   every: 10s
    warn: ($this > ($1h_kv_get_mean_latency * 2) )
    crit: ($this > ($1h_kv_get_mean_latency * 3) )
    info: average KV GET time over the last 3 minutes, compared to the average over the last hour
   delay: down 5m multiplier 1.5 max 1h
      to: dba
