#!/usr/bin/env bash
#shellcheck disable=SC2001

# netdata
# real-time performance and health monitoring, done right!
# (C) 2016 Costa Tsaousis <costa@tsaousis.gr>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Script to find a better name for cgroups
#

export PATH="${PATH}:/sbin:/usr/sbin:/usr/local/sbin"
export LC_ALL=C

# -----------------------------------------------------------------------------

PROGRAM_NAME="$(basename "${0}")"

logdate() {
	date "+%Y-%m-%d %H:%M:%S"
}

log() {
	local status="${1}"
	shift

	echo >&2 "$(logdate): ${PROGRAM_NAME}: ${status}: ${*}"

}

warning() {
	log WARNING "${@}"
}

error() {
	log ERROR "${@}"
}

info() {
	log INFO "${@}"
}

fatal() {
	log FATAL "${@}"
	exit 1
}

function docker_like_get_name_command() {
	local command="${1}"
	local id="${2}"
	info "Running command: ${command} ps --filter=id=\"${id}\" --format=\"{{.Names}}\""
	NAME="$(${command} ps --filter=id="${id}" --format="{{.Names}}")"
	return 0
}

function docker_like_get_name_api() {
	local host_var="${1}"
	local host="${!host_var}"
	local path="/containers/${2}/json"
	if [ -z "${host}" ]; then
		warning "No ${host_var} is set"
		return 1
	fi
	if ! command -v jq >/dev/null 2>&1; then
		warning "Can't find jq command line tool. jq is required for netdata to retrieve container name using ${host} API, falling back to docker ps"
		return 1
	fi
	if [ -S "${host}" ]; then
		info "Running API command: curl --unix-socket \"${host}\" http://localhost${path}"
		JSON=$(curl -sS --unix-socket "${host}" "http://localhost${path}")
	else
		info "Running API command: curl \"${host}${path}\""
		JSON=$(curl -sS "${host}${path}")
	fi
	NAME=$(echo "${JSON}" | jq -r .Name,.Config.Hostname | grep -v null | head -n1 | sed 's|^/||')
	return 0
}

# get_lbl_val returns the value for the label with the given name.
# Returns an empty string if the label doesn't exist.
# Expected labels format: 'name="value",...'.
function get_lbl_val() {
  local labels want_name
  labels="${1}"
  want_name="${2}"

  IFS=, read -ra labels <<< "$labels"

  local lname lval
  for l in "${labels[@]}"; do
    IFS="=" read -r lname lval <<< "$l"
    if [ "$want_name" = "$lname" ] && [ -n "$lval" ]; then
      echo "${lval:1:-1}" # trim "
      return 0
    fi
  done

  return 1
}

# k8s_get_kubepod_name gets pod or container level cgroup name from the k8s API server.
# pod name format: 'pod_<namespace>_<pod_name>'
# container name format: 'cntr_<namespace>_<pod_name>_<container_name>'
function k8s_get_kubepod_name() {
  local funcname="${FUNCNAME[0]}"
  local id="${1}"

  if [[ ! "${id}" =~ ^kube.*_pod.*$ ]]; then
    warning "${funcname}: '${id}' is not kubepod."
    return 1
  fi

  local pod_uid cntr_id
  IFS=_ read -r pod_uid cntr_id <<< "${id##*_pod}"

  if [ -z "$pod_uid" ] && [ -z "$cntr_id" ]; then
    warning "${funcname}: can't extract pod_uid or container_id from '${id}'."
    return 1
  fi

  local data
  if [ -n "${KUBERNETES_SERVICE_HOST}" ] && [ -n "${KUBERNETES_PORT_443_TCP_PORT}" ]; then
    local token header url
    token="$(< /var/run/secrets/kubernetes.io/serviceaccount/token)"
    header="Authorization: Bearer $token"
    url="https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_PORT_443_TCP_PORT/api/v1/pods"
    if ! data=$(curl -sSk -H "$header" "$url" 2>&1); then
      warning "${funcname}: error on curl '${url}': ${data}."
      return 1
    fi
  elif ps -C kubelet > /dev/null 2>&1 && command -v kubectl > /dev/null 2>&1; then
    [[ -z ${KUBE_CONFIG+x} ]] && KUBE_CONFIG="/etc/kubernetes/admin.conf"
    if ! data=$(kubectl --kubeconfig="$KUBE_CONFIG" get pods --all-namespaces -o json 2>&1); then
      warning "${funcname}: error on 'kubectl get pods --all-namespaces -o json': ${data}."
      return 1
    fi
  else
    warning "${funcname}: not inside the k8s cluster and 'kubectl' command not available."
    return 1
  fi

  local jq_pod jq_cont jq_filter
  jq_pod='namespace=\"\(.metadata.namespace)\",pod_name=\"\(.metadata.name)\",pod_uid=\"\(.metadata.uid)\"'
  jq_cont=',container_name=\"\(.name)\",container_id=\"\(.containerID)\"'
  jq_filter=".items[] | \"${jq_pod}\" + (.status.containerStatuses[]? | \"${jq_cont}\") | sub(\"docker://\";\"\")"

  if ! data=$(jq -r "${jq_filter}" <<< "$data" 2>&1); then
    warning "${funcname}: error on 'jq -r '${jq_filter}'': ${data}."
    return 1
  fi

  local labels name
  if [ -n "$cntr_id" ]; then
    if labels=$(grep "$cntr_id" <<< "$data" 2> /dev/null); then
      name="cntr_$(get_lbl_val "$labels" namespace)_$(get_lbl_val "$labels" pod_name)_$(get_lbl_val "$labels" container_name)"
    fi
  elif [ -n "$pod_uid" ]; then
    if labels=$(grep "$pod_uid" -m 1 <<< "$data" 2> /dev/null); then
      labels="${labels%%,cont*}"
      name="pod_$(get_lbl_val "$labels" namespace)_$(get_lbl_val "$labels" pod_name)"
    fi
  fi

  echo "$name"
  [[ -n "$name" ]]
  return
}

function k8s_get_name() {
  local funcname="${FUNCNAME[0]}"
  local orig_id="${1}"
  local id=${orig_id//.slice/} # minikube ids sanitizing

  case "$id" in
    "kubepods" | "kubepods_guaranteed" | "kubepods_burstable" | "kubepods_besteffort")
      NAME="${id}"
      ;;
  esac

  if [ -z "$NAME" ]; then
    NAME=$(k8s_get_kubepod_name "$id")
  fi

  if [ -z "${NAME}" ]; then
    warning "${funcname}: cannot find the name of cgroup with id '${id}'. Setting name to ${id} and disabling it."
    NAME="${id}"
    NAME_NOT_FOUND=3
  else
    NAME="k8s_${NAME}"
    info "${funcname}: cgroup '${id}' has chart name '${NAME}'"
  fi
}

function docker_get_name() {
	local id="${1}"
	if hash docker 2>/dev/null; then
		docker_like_get_name_command docker "${id}"
	else
		docker_like_get_name_api DOCKER_HOST "${id}" || docker_like_get_name_command podman "${id}"
	fi
	if [ -z "${NAME}" ]; then
		warning "cannot find the name of docker container '${id}'"
		NAME_NOT_FOUND=2
		NAME="${id:0:12}"
	else
		info "docker container '${id}' is named '${NAME}'"
	fi
}

function docker_validate_id() {
	local id="${1}"
	if [ -n "${id}" ] && { [ ${#id} -eq 64 ] || [ ${#id} -eq 12 ]; }; then
		docker_get_name "${id}"
	else
		error "a docker id cannot be extracted from docker cgroup '${CGROUP}'."
	fi
}

function podman_get_name() {
	local id="${1}"

	# for Podman, prefer using the API if we can, as netdata will not normally have access
	# to other users' containers, so they will not be visible when running `podman ps`
	docker_like_get_name_api PODMAN_HOST "${id}" || docker_like_get_name_command podman "${id}"

	if [ -z "${NAME}" ]; then
		warning "cannot find the name of podman container '${id}'"
		NAME_NOT_FOUND=2
		NAME="${id:0:12}"
	else
		info "podman container '${id}' is named '${NAME}'"
	fi
}

function podman_validate_id() {
	local id="${1}"
	if [ -n "${id}" ] && [ ${#id} -eq 64 ]; then
		podman_get_name "${id}"
	else
		error "a podman id cannot be extracted from docker cgroup '${CGROUP}'."
	fi
}

# -----------------------------------------------------------------------------

[ -z "${NETDATA_USER_CONFIG_DIR}" ] && NETDATA_USER_CONFIG_DIR="@configdir_POST@"
[ -z "${NETDATA_STOCK_CONFIG_DIR}" ] && NETDATA_STOCK_CONFIG_DIR="@libconfigdir_POST@"

DOCKER_HOST="${DOCKER_HOST:=/var/run/docker.sock}"
PODMAN_HOST="${PODMAN_HOST:=/run/podman/podman.sock}"
CGROUP="${1}"
NAME_NOT_FOUND=0
NAME=

# -----------------------------------------------------------------------------

if [ -z "${CGROUP}" ]; then
	fatal "called without a cgroup name. Nothing to do."
fi

for CONFIG in "${NETDATA_USER_CONFIG_DIR}/cgroups-names.conf" "${NETDATA_STOCK_CONFIG_DIR}/cgroups-names.conf"; do
	if [ -f "${CONFIG}" ]; then
		NAME="$(grep "^${CGROUP} " "${CONFIG}" | sed 's/[[:space:]]\+/ /g' | cut -d ' ' -f 2)"
		if [ -z "${NAME}" ]; then
			info "cannot find cgroup '${CGROUP}' in '${CONFIG}'."
		else
			break
		fi
	#else
	#   info "configuration file '${CONFIG}' is not available."
	fi
done

if [ -z "${NAME}" ]; then
	if [[ ${CGROUP} =~ ^.*kubepods.* ]]; then
		k8s_get_name "${CGROUP}"
	fi
fi

if [ -z "${NAME}" ]; then
	if [[ ${CGROUP} =~ ^.*docker[-_/\.][a-fA-F0-9]+[-_\.]?.*$ ]]; then
		# docker containers
		#shellcheck disable=SC1117
		DOCKERID="$(echo "${CGROUP}" | sed "s|^.*docker[-_/]\([a-fA-F0-9]\+\)[-_\.]\?.*$|\1|")"
		docker_validate_id "${DOCKERID}"
	elif [[ ${CGROUP} =~ ^.*ecs[-_/\.][a-fA-F0-9]+[-_\.]?.*$ ]]; then
		# ECS
		#shellcheck disable=SC1117
		DOCKERID="$(echo "${CGROUP}" | sed "s|^.*ecs[-_/].*[-_/]\([a-fA-F0-9]\+\)[-_\.]\?.*$|\1|")"
		docker_validate_id "${DOCKERID}"
	elif [[ ${CGROUP} =~ ^.*libpod-[a-fA-F0-9]+.*$ ]]; then
		# Podman
		PODMANID="$(echo "${CGROUP}" | sed "s|^.*libpod-\([a-fA-F0-9]\+\).*$|\1|")"
		podman_validate_id "${PODMANID}"

	elif [[ ${CGROUP} =~ machine.slice[_/].*\.service ]]; then
		# systemd-nspawn
		NAME="$(echo "${CGROUP}" | sed 's/.*machine.slice[_\/]\(.*\)\.service/\1/g')"

	elif [[ ${CGROUP} =~ machine.slice_machine.*-qemu ]]; then
		# libvirtd / qemu virtual machines
		# NAME="$(echo ${CGROUP} | sed 's/machine.slice_machine.*-qemu//; s/\/x2d//; s/\/x2d/\-/g; s/\.scope//g')"
		NAME="qemu_$(echo "${CGROUP}" | sed 's/machine.slice_machine.*-qemu//; s/\/x2d[[:digit:]]*//; s/\/x2d//g; s/\.scope//g')"

	elif [[ ${CGROUP} =~ machine_.*\.libvirt-qemu ]]; then
		# libvirtd / qemu virtual machines
		NAME="qemu_$(echo "${CGROUP}" | sed 's/^machine_//; s/\.libvirt-qemu$//; s/-/_/;')"

	elif [[ ${CGROUP} =~ qemu.slice_([0-9]+).scope && -d /etc/pve ]]; then
		# Proxmox VMs

		FILENAME="/etc/pve/qemu-server/${BASH_REMATCH[1]}.conf"
		if [[ -f $FILENAME && -r $FILENAME ]]; then
			NAME="qemu_$(grep -e '^name: ' "/etc/pve/qemu-server/${BASH_REMATCH[1]}.conf" | head -1 | sed -rn 's|\s*name\s*:\s*(.*)?$|\1|p')"
		else
			error "proxmox config file missing ${FILENAME} or netdata does not have read access.  Please ensure netdata is a member of www-data group."
		fi
	elif [[ ${CGROUP} =~ lxc_([0-9]+) && -d /etc/pve ]]; then
		# Proxmox Containers (LXC)

		FILENAME="/etc/pve/lxc/${BASH_REMATCH[1]}.conf"
		if [[ -f ${FILENAME} && -r ${FILENAME} ]]; then
			NAME=$(grep -e '^hostname: ' "/etc/pve/lxc/${BASH_REMATCH[1]}.conf" | head -1 | sed -rn 's|\s*hostname\s*:\s*(.*)?$|\1|p')
		else
			error "proxmox config file missing ${FILENAME} or netdata does not have read access.  Please ensure netdata is a member of www-data group."
		fi
	elif [[ ${CGROUP} =~ lxc.payload.* ]]; then
		# LXC 4.0
		NAME="$(echo "${CGROUP}" | sed 's/lxc\.payload\.\(.*\)/\1/g')"
	fi

	[ -z "${NAME}" ] && NAME="${CGROUP}"
	[ ${#NAME} -gt 100 ] && NAME="${NAME:0:100}"
fi

info "cgroup '${CGROUP}' is called '${NAME}'"
echo "${NAME}"

exit ${NAME_NOT_FOUND}

