exporting/check_filters.c:        host->exporting_flags = callocz(instance->engine->instance_num, sizeof(size_t));
exporting/check_filters.c:    RRDHOST_FLAGS *flags = &host->exporting_flags[instance->index];
exporting/check_filters.c:        if (!instance->config.hosts_pattern || simple_pattern_matches(instance->config.hosts_pattern, host_name)) {
exporting/check_filters.c:            info("enabled exporting of host '%s' for instance '%s'", host_name, instance->config.name);
exporting/check_filters.c:            info("disabled exporting of host '%s' for instance '%s'", host_name, instance->config.name);
exporting/check_filters.c:        st->exporting_flags = callocz(instance->engine->instance_num, sizeof(size_t));
exporting/check_filters.c:    RRDSET_FLAGS *flags = &st->exporting_flags[instance->index];
exporting/check_filters.c:        if(simple_pattern_matches(instance->config.charts_pattern, st->id) || simple_pattern_matches(instance->config.charts_pattern, st->name))
exporting/check_filters.c:    if(unlikely(st->rrd_memory_mode == RRD_MEMORY_MODE_NONE && !(EXPORTING_OPTIONS_DATA_SOURCE(instance->config.options) == EXPORTING_SOURCE_DATA_AS_COLLECTED))) {
exporting/clean_connectors.c:    clean_instance_config(&instance->config);
exporting/clean_connectors.c:    buffer_free(instance->labels);
exporting/clean_connectors.c:    uv_cond_destroy(&instance->cond_var);
exporting/clean_connectors.c:    // uv_mutex_destroy(&instance->mutex);
exporting/exporting_engine.c:        instance = instance->next;
exporting/exporting_engine.c:        if (current_instance->config.type == EXPORTING_CONNECTOR_TYPE_PROMETHEUS_REMOTE_WRITE && engine->protocol_buffers_initialized) {
exporting/exporting_engine.c:        } else if (current_instance->config.type == EXPORTING_CONNECTOR_TYPE_KINESIS
exporting/exporting_engine.c:                 && current_instance->engine->aws_sdk_initialized && engine->aws_sdk_initialized) {
exporting/exporting_engine.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/exporting_engine.c:        if (!instance->exited) {
exporting/exporting_engine.c:            info("stopping worker for instance %s", instance->config.name);
exporting/exporting_engine.c:            uv_mutex_unlock(&instance->mutex);
exporting/exporting_engine.c:            uv_cond_signal(&instance->cond_var);
exporting/exporting_engine.c:            info("found stopped worker for instance %s", instance->config.name);
exporting/exporting_engine.c:        for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/exporting_engine.c:            if (!instance->exited)
exporting/exporting_engine.h:    (instance->config.options & (EXPORTING_OPTION_SEND_CONFIGURED_LABELS | EXPORTING_OPTION_SEND_AUTOMATIC_LABELS))
exporting/exporting_engine.h:    ((instance->config.options & EXPORTING_OPTION_SEND_CONFIGURED_LABELS &&                                            \
exporting/exporting_engine.h:     (instance->config.options & EXPORTING_OPTION_SEND_AUTOMATIC_LABELS &&                                             \
exporting/exporting_engine.h:    instance->disabled = 1;
exporting/exporting_engine.h:    instance->scheduled = 0;
exporting/exporting_engine.h:    uv_mutex_unlock(&instance->mutex);
exporting/exporting_engine.h:    error("EXPORTING: Instance %s disabled", instance->config.name);
exporting/init_connectors.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/init_connectors.c:        instance->index = engine->instance_num++;
exporting/init_connectors.c:        instance->after = engine->now;
exporting/init_connectors.c:        switch (instance->config.type) {
exporting/init_connectors.c:        int error = uv_thread_create(&instance->thread, instance->worker, instance);
exporting/init_connectors.c:        snprintfz(threadname, NETDATA_THREAD_NAME_MAX, "EXPORTING-%zu", instance->index);
exporting/init_connectors.c:        uv_thread_set_name_np(instance->thread, threadname);
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (!instance->disabled && (engine->now % instance->config.update_every < localhost->rrd_update_every)) {
exporting/process_data.c:            instance->scheduled = 1;
exporting/process_data.c:            instance->before = engine->now;
exporting/process_data.c:    time_t after = instance->after;
exporting/process_data.c:    time_t before = instance->before;
exporting/process_data.c:    if (unlikely(EXPORTING_OPTIONS_DATA_SOURCE(instance->config.options) == EXPORTING_SOURCE_DATA_SUM))
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled) {
exporting/process_data.c:            uv_mutex_lock(&instance->mutex);
exporting/process_data.c:            if (instance->start_batch_formatting && instance->start_batch_formatting(instance) != 0) {
exporting/process_data.c:                error("EXPORTING: cannot start batch formatting for %s", instance->config.name);
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled) {
exporting/process_data.c:                if (instance->start_host_formatting && instance->start_host_formatting(instance, host) != 0) {
exporting/process_data.c:                    error("EXPORTING: cannot start host formatting for %s", instance->config.name);
exporting/process_data.c:                instance->skip_host = 1;
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled && !instance->skip_host) {
exporting/process_data.c:                if (instance->start_chart_formatting && instance->start_chart_formatting(instance, st) != 0) {
exporting/process_data.c:                    error("EXPORTING: cannot start chart formatting for %s", instance->config.name);
exporting/process_data.c:                instance->skip_chart = 1;
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled && !instance->skip_host && !instance->skip_chart) {
exporting/process_data.c:            if (instance->metric_formatting && instance->metric_formatting(instance, rd) != 0) {
exporting/process_data.c:                error("EXPORTING: cannot format metric for %s", instance->config.name);
exporting/process_data.c:            instance->stats.buffered_metrics++;
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled && !instance->skip_host && !instance->skip_chart) {
exporting/process_data.c:            if (instance->end_chart_formatting && instance->end_chart_formatting(instance, st) != 0) {
exporting/process_data.c:                error("EXPORTING: cannot end chart formatting for %s", instance->config.name);
exporting/process_data.c:        instance->skip_chart = 0;
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled && !instance->skip_host) {
exporting/process_data.c:            if (instance->end_host_formatting && instance->end_host_formatting(instance, host) != 0) {
exporting/process_data.c:                error("EXPORTING: cannot end host formatting for %s", instance->config.name);
exporting/process_data.c:        instance->skip_host = 0;
exporting/process_data.c:    for (struct instance *instance = engine->instance_root; instance; instance = instance->next) {
exporting/process_data.c:        if (instance->scheduled) {
exporting/process_data.c:            if (instance->end_batch_formatting && instance->end_batch_formatting(instance) != 0) {
exporting/process_data.c:                error("EXPORTING: cannot end batch formatting for %s", instance->config.name);
exporting/process_data.c:            uv_mutex_unlock(&instance->mutex);
exporting/process_data.c:            uv_cond_signal(&instance->cond_var);
exporting/process_data.c:            instance->scheduled = 0;
exporting/process_data.c:            instance->after = instance->before;
exporting/process_data.c:    if (instance->labels)
exporting/process_data.c:        buffer_flush(instance->labels);
exporting/process_data.c:    instance->stats.buffered_bytes = (collected_number)buffer_strlen((BUFFER *)(instance->buffer));
exporting/read_config.c:        prometheus_exporter_instance->config.update_every =
exporting/read_config.c:            prometheus_exporter_instance->config.options |= EXPORTING_OPTION_SEND_NAMES;
exporting/read_config.c:            prometheus_exporter_instance->config.options &= ~EXPORTING_OPTION_SEND_NAMES;
exporting/read_config.c:            prometheus_exporter_instance->config.options |= EXPORTING_OPTION_SEND_CONFIGURED_LABELS;
exporting/read_config.c:            prometheus_exporter_instance->config.options &= ~EXPORTING_OPTION_SEND_CONFIGURED_LABELS;
exporting/read_config.c:            prometheus_exporter_instance->config.options |= EXPORTING_OPTION_SEND_AUTOMATIC_LABELS;
exporting/read_config.c:            prometheus_exporter_instance->config.options &= ~EXPORTING_OPTION_SEND_AUTOMATIC_LABELS;
exporting/read_config.c:        prometheus_exporter_instance->config.charts_pattern =
exporting/read_config.c:        prometheus_exporter_instance->config.hosts_pattern = simple_pattern_create(
exporting/read_config.c:        tmp_instance->next = engine->instance_root;
exporting/read_config.c:        tmp_instance->engine = engine;
exporting/read_config.c:        tmp_instance->config.type = tmp_ci_list->backend_type;
exporting/read_config.c:        tmp_instance->config.name = strdupz(tmp_ci_list->local_ci.instance_name);
exporting/read_config.c:        tmp_instance->config.update_every =
exporting/read_config.c:        tmp_instance->config.buffer_on_failures = exporter_get_number(instance_name, "buffer on failures", 10);
exporting/read_config.c:        tmp_instance->config.timeoutms = exporter_get_number(instance_name, "timeout ms", 10000);
exporting/read_config.c:        tmp_instance->config.charts_pattern =
exporting/read_config.c:        tmp_instance->config.hosts_pattern = simple_pattern_create(
exporting/read_config.c:        tmp_instance->config.options = exporting_parse_data_source(data_source, tmp_instance->config.options);
exporting/read_config.c:            tmp_instance->config.options |= EXPORTING_OPTION_SEND_CONFIGURED_LABELS;
exporting/read_config.c:            tmp_instance->config.options &= ~EXPORTING_OPTION_SEND_CONFIGURED_LABELS;
exporting/read_config.c:            tmp_instance->config.options |= EXPORTING_OPTION_SEND_AUTOMATIC_LABELS;
exporting/read_config.c:            tmp_instance->config.options &= ~EXPORTING_OPTION_SEND_AUTOMATIC_LABELS;
exporting/read_config.c:            tmp_instance->config.options |= EXPORTING_OPTION_SEND_NAMES;
exporting/read_config.c:            tmp_instance->config.options &= ~EXPORTING_OPTION_SEND_NAMES;
exporting/read_config.c:        if (tmp_instance->config.type == EXPORTING_CONNECTOR_TYPE_PROMETHEUS_REMOTE_WRITE) {
exporting/read_config.c:            tmp_instance->config.connector_specific_config = connector_specific_config;
exporting/read_config.c:        if (tmp_instance->config.type == EXPORTING_CONNECTOR_TYPE_KINESIS) {
exporting/read_config.c:            tmp_instance->config.connector_specific_config = connector_specific_config;
exporting/read_config.c:        if (tmp_instance->config.type == EXPORTING_CONNECTOR_TYPE_PUBSUB) {
exporting/read_config.c:            tmp_instance->config.connector_specific_config = connector_specific_config;
exporting/read_config.c:        if (tmp_instance->config.type == EXPORTING_CONNECTOR_TYPE_MONGODB) {
exporting/read_config.c:            tmp_instance->config.connector_specific_config = connector_specific_config;
exporting/read_config.c:        tmp_instance->config.destination = strdupz(exporter_get(instance_name, "destination", default_destination));
exporting/read_config.c:            tmp_instance->config.destination,
exporting/read_config.c:            tmp_instance->config.update_every,
exporting/read_config.c:            tmp_instance->config.buffer_on_failures,
exporting/read_config.c:            tmp_instance->config.timeoutms,
exporting/read_config.c:            tmp_instance->config.options);
exporting/send_data.c:        instance->config.name,
exporting/send_data.c:    struct stats *stats = &instance->stats;
exporting/send_data.c:            error("EXPORTING: '%s' closed the socket", instance->config.destination);
exporting/send_data.c:                error("EXPORTING: cannot receive data from '%s'.", instance->config.destination);
exporting/send_data.c:        instance->check_response(response, instance);
exporting/send_data.c:    BUFFER *buffer = (BUFFER *)instance->buffer;
exporting/send_data.c:    struct stats *stats = &instance->stats;
exporting/send_data.c:    if (instance->send_header)
exporting/send_data.c:        ret = instance->send_header(sock, instance);
exporting/send_data.c:            instance->config.destination,
exporting/send_data.c:    info("EXPORTING: cleaning up instance %s ...", instance->config.name);
exporting/send_data.c:    buffer_free(instance->buffer);
exporting/send_data.c:    freez(instance->config.connector_specific_config);
exporting/send_data.c:    if (instance->config.type == EXPORTING_CONNECTOR_TYPE_PROMETHEUS_REMOTE_WRITE)
exporting/send_data.c:    info("EXPORTING: instance %s exited", instance->config.name);
exporting/send_data.c:    instance->exited = 1;
exporting/send_data.c:    struct simple_connector_config *connector_specific_config = instance->config.connector_specific_config;
exporting/send_data.c:    struct stats *stats = &instance->stats;
exporting/send_data.c:    struct timeval timeout = {.tv_sec = (instance->config.timeoutms * 1000) / 1000000,
exporting/send_data.c:                              .tv_usec = (instance->config.timeoutms * 1000) % 1000000};
exporting/send_data.c:    while(!instance->engine->exit) {
exporting/send_data.c:                instance->config.destination,
exporting/send_data.c:        if(unlikely(instance->engine->exit)) break;
exporting/send_data.c:        uv_mutex_lock(&instance->mutex);
exporting/send_data.c:        uv_cond_wait(&instance->cond_var, &instance->mutex);
exporting/send_data.c:        if (unlikely(instance->engine->exit)) {
exporting/send_data.c:            uv_mutex_unlock(&instance->mutex);
exporting/send_data.c:            error("EXPORTING: failed to update '%s'", instance->config.destination);
exporting/send_data.c:        BUFFER *buffer = instance->buffer;
exporting/send_data.c:        if (failures > instance->config.buffer_on_failures) {
exporting/send_data.c:                instance->config.name, failures, instance->config.destination);
exporting/send_data.c:        uv_mutex_unlock(&instance->mutex);
exporting/send_internal_metrics.c:    struct stats *stats = &instance->stats;
exporting/send_internal_metrics.c:        buffer_sprintf(family, "exporting_%s", instance->config.name);
exporting/send_internal_metrics.c:        snprintf(id, RRD_ID_LENGTH_MAX, "exporting_%s_metrics", instance->config.name);
exporting/send_internal_metrics.c:            130610, instance->config.update_every, RRDSET_TYPE_LINE);
exporting/send_internal_metrics.c:        snprintf(id, RRD_ID_LENGTH_MAX, "exporting_%s_bytes", instance->config.name);
exporting/send_internal_metrics.c:            130620, instance->config.update_every, RRDSET_TYPE_AREA);
exporting/send_internal_metrics.c:        snprintf(id, RRD_ID_LENGTH_MAX, "exporting_%s_ops", instance->config.name);
exporting/send_internal_metrics.c:            NULL, 130630, instance->config.update_every, RRDSET_TYPE_LINE);
exporting/send_internal_metrics.c:        snprintf(id, RRD_ID_LENGTH_MAX, "exporting_%s_thread_cpu", instance->config.name);
exporting/send_internal_metrics.c:            "milliseconds/s", "exporting", NULL, 130640, instance->config.update_every, RRDSET_TYPE_STACKED);
